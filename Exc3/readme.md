# Анализ

При синхронном взаимодейстивии организауетя беспрерывная цепочка вызовов сервисов. Вероятность сбоя при добавлении каждого дополнительного элемента цепочки вызовов увеличивается, что в пределе дает систему, которая всегда не работает.

Использования политик повтора ограничено временем ожидания ответа клиентом от сервера. При длительном сбое во время записи ошибка приведет к рассогласованию данных, которое сложно исправить. При сбоях во время чтения время ответа будет расти или пользователь будет получать ошибки.

Для устранения расогласованности необходимо использовать асинхронное взаимодействие + OUTBOX, или комбинацию синхронного + фоновый процесс + OUTBOX: сихноронный запрос в одной транзакции с основными данными добавляет запись в outbox и пытается отправить сообщение. Фоновый процесс отправляет все, что не смог отправить сихронный запрос

Для устранени проблемы долгих ответов на запросы необходимо использовать локальные кеши, наполняетмые через EDA, но это увеличивает расход ресурсов хранилища на хранение копии данных

Агрегирование множества данных в единый список усложняет постраничную выборку с сортировкой.

Можно частично утащить идею твиттера и расчитывать для каждого клиента доступные продукты при их появлении, занося их в быстрое хранилище, т.е.: у компании появляется новый продукт, каждому пользователю добавляется этот продукт в список доступных, если доступен. Выборка бубет рабоать быстро. Усложнится изменени и удаление. Обычно продукты обновлять нельзя. Заводятся только новые. Удаление можно заменить датой с окончанием действия предложения по продукту

С учетом отсутствия ограничений на ресурсы:
1. Добавить в каждый сервис локальный кеш агрегатора
2. Для каждого клиента посчитать кеш доступных ему продукто. Оттуда брать дынные для возврата клиенту. С учетом отсутствия у конечного пользователя данных о правилах предоставления продуктов, даже если будет задержка в расчетах никто не сможет утверждать, что она существует